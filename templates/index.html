<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Intrusion Detection System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: radial-gradient(1400px 700px at 20% -10%, #1a237e 0%, transparent 60%),
                        radial-gradient(1400px 700px at 100% 10%, #4a148c 0%, transparent 60%),
                        linear-gradient(180deg, #0b1020 0%, #0a0f1f 100%);
            color: #e6ecff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            font-size: 2.5em;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .status-card {
            background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
            border-radius: 16px;
            padding: 20px;
            margin: 20px 0;
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255,255,255,0.12);
            box-shadow: 0 20px 40px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.15);
        }
        .controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        }
        .btn-primary { background: linear-gradient(135deg, #00e5ff, #00c853); color: #04121f; }
        .btn-primary:hover { transform: translateY(-2px) scale(1.02); filter: brightness(1.05); }
        .btn-danger {
            background: #f44336;
            color: white;
        }
        .btn-danger:hover { background: #da190b; transform: translateY(-2px) scale(1.02); }
        .btn-secondary { background: linear-gradient(135deg, #7c4dff, #448aff); color: #eef2ff; }
        .btn-secondary:hover { transform: translateY(-2px) scale(1.02); }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .stat-item {
            background: radial-gradient(120% 140% at 0% 0%, rgba(124,77,255,0.18), rgba(255,255,255,0.06));
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.15);
        }
        .stat-value {
            font-size: 2.2em;
            font-weight: 800;
            color: #a5f7b0;
            text-shadow: 0 0 18px rgba(0,255,170,0.35);
        }
        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 5px;
        }
        .chart-container {
            background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
            border-radius: 16px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid rgba(255,255,255,0.12);
            box-shadow: 0 20px 40px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.15);
        }
        /* placeholder for future KPI widgets */
        .events-log {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
        }
        .event-item {
            margin: 5px 0;
            padding: 8px;
            border-radius: 5px;
            background: rgba(255,255,255,0.1);
        }
        .event-threat {
            background: rgba(244, 67, 54, 0.3);
            border-left: 4px solid #f44336;
        }
        .event-anomaly {
            background: rgba(255, 193, 7, 0.3);
            border-left: 4px solid #ffc107;
        }
        .event-normal {
            background: rgba(76, 175, 80, 0.3);
            border-left: 4px solid #4CAF50;
        }
        .interface-selector {
            margin: 20px 0;
        }
        .interface-selector select {
            padding: 10px;
            border-radius: 5px;
            border: none;
            background: rgba(255,255,255,0.9);
            color: #333;
            font-size: 16px;
            width: 100%;
            max-width: 400px;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-running { background: #00e676; animation: pulse 2s infinite; box-shadow: 0 0 18px rgba(0,230,118,0.6); }
        .status-stopped {
            background: #f44336;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        /* Toast notification */
        .toast {
            position: fixed;
            right: 20px;
            top: 20px;
            min-width: 260px;
            max-width: 420px;
            background: rgba(0,0,0,0.8);
            color: #fff;
            padding: 14px 16px;
            border-radius: 8px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.3);
            transform: translateY(-20px);
            opacity: 0;
            transition: all .3s ease;
            z-index: 9999;
        }
        .toast.show { opacity: 1; transform: translateY(0); }
        .toast.warn { background: rgba(244, 67, 54, 0.95); }
        .toast.info { background: rgba(33, 150, 243, 0.95); }
        .toast .title { font-weight: 700; margin-bottom: 4px; }
        .toast .small { font-size: 12px; opacity: .9; }
        /* Modal for offline results */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9998;
        }
        .modal {
            width: min(800px, 92vw);
            background: #1f1f2e;
            color: #fff;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.12);
            animation: pop .2s ease;
        }
        .modal h3 { margin-top: 0; }
        .modal .actions { text-align: right; margin-top: 12px; }
        .modal .actions .btn { margin-left: 8px; }
        @keyframes pop { from { transform: scale(.96); opacity: .9; } to { transform: scale(1); opacity: 1; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üõ°Ô∏è Live Intrusion Detection System</h1>
            <p>Real-time AI-powered network security monitoring</p>
        </div>

        <!-- Mode Switcher -->
        <div class="status-card" style="display:flex;gap:12px;align-items:center;justify-content:flex-start;">
            <strong>Mode:</strong>
            <button class="btn btn-secondary" id="btnLive" onclick="switchMode('live')">Live Detection</button>
            <button class="btn btn-secondary" id="btnOffline" onclick="switchMode('offline')">Offline Analysis</button>
        </div>

        <div id="liveSection">
        <div class="status-card">
            <h2>System Status</h2>
            <p>
                <span class="status-indicator status-stopped" id="statusIndicator"></span>
                <span id="statusText">System Stopped</span>
            </p>
            
            <div class="interface-selector">
                <label for="interfaceSelect">Select Network Interface:</label>
                <select id="interfaceSelect">
                    <option value="">Loading interfaces...</option>
                </select>
            </div>

            <div class="controls">
                <button class="btn btn-primary" id="startBtn" onclick="startCapture()">Start Capture</button>
                <button class="btn btn-danger" id="stopBtn" onclick="stopCapture()" disabled>Stop Capture</button>
                <button class="btn btn-secondary" onclick="clearLog()">Clear Log</button>
            </div>
        </div>

        <div class="stats-grid">
            <div class="stat-item">
                <div class="stat-value" id="packetCount">0</div>
                <div class="stat-label">Packets Processed</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="threatCount">0</div>
                <div class="stat-label">Threats Detected</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="anomalyCount">0</div>
                <div class="stat-label">Anomalies Found</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="packetsCaptured">0</div>
                <div class="stat-label">Packets Captured</div>
            </div>
        </div>

        <div class="chart-container">
            <h3>Threat Detection Timeline</h3>
            <div id="threatChart" style="height: 300px;"></div>
        </div>

        <div class="chart-container">
            <h3>Traffic Classification</h3>
            <div id="classificationChart" style="height: 300px;"></div>
        </div>

        <div class="status-card">
            <h3>Recent Events</h3>
            <div class="events-log" id="eventsLog">
                <div class="event-item event-normal">
                    <strong>[INFO]</strong> System ready. Select interface and start capture.
                </div>
            </div>
        </div>
        
        <!-- Removed anomaly gauge for now; will replace with improved KPI panel in next iteration -->
        </div> <!-- end liveSection -->

        <div id="offlineSection" style="display:none;">
        <div class="status-card">
            <h2>Offline PCAP Analysis</h2>
            <p>Upload a .pcap/.pcapng file to analyze without live capture.</p>
            <input type="file" id="pcapFile" accept=".pcap,.pcapng" />
            <button class="btn btn-secondary" onclick="uploadPcap()">Analyze PCAP</button>
            <div id="pcapResult" style="margin-top:10px;font-size:14px;"></div>
        </div>
        </div> <!-- end offlineSection -->
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast"></div>
    <!-- Threat Siren Banner -->
    <div id="sirenBanner" style="display:none;position:fixed;left:0;right:0;top:0;padding:14px 16px;background:linear-gradient(90deg, rgba(244,67,54,0.95), rgba(255,82,82,0.95));color:#fff;font-weight:800;text-align:center;letter-spacing:1px;z-index:9998;box-shadow:0 10px 30px rgba(244,67,54,0.4)">üö® THREAT DETECTED</div>
    <audio id="sirenAudio" preload="auto">
        <source src="https://actions.google.com/sounds/v1/alarms/alarm_clock.ogg" type="audio/ogg">
    </audio>
    <!-- Modal for results -->
    <div id="modalOverlay" class="modal-overlay" onclick="hideModal(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <h3 id="modalTitle">Results</h3>
            <div id="modalBody"></div>
            <div class="actions">
                <button class="btn btn-secondary" onclick="hideModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        let isCapturing = false;
        let packetCount = 0;
        let threatCount = 0;
        let anomalyCount = 0;
        let startTime = Date.now();

        // Socket event handlers
        socket.on('connect', function() {
            console.log('Connected to server');
            addEvent('Connected to server', 'normal');
        });

        socket.on('disconnect', function() {
            console.log('Disconnected from server');
            addEvent('Disconnected from server', 'normal');
        });

        socket.on('interfaces', function(data) {
            updateInterfaces(data.interfaces);
        });

        // Handle server-emitted interfaces payload on connect
        socket.on('interfaces_loaded', function(interfaces) {
            updateInterfaces(interfaces);
        });

        socket.on('status_update', function(data) {
            updateStatus(data);
        });

        socket.on('update_stats', function(data) {
            updateStats(data);
        });

        socket.on('new_prediction', function(data) {
            handlePrediction(data);
        });

        socket.on('threat_alert', function(data) {
            handleThreatAlert(data);
        });

        // Functions
        function updateInterfaces(interfaces) {
            const select = document.getElementById('interfaceSelect');
            select.innerHTML = '<option value="">Select an interface...</option>';
            
            interfaces.forEach(iface => {
                const option = document.createElement('option');
                option.value = iface.name;
                const ip = (iface.addresses && iface.addresses.length && iface.addresses[0].ip) ? iface.addresses[0].ip : 'No IP';
                const ssid = iface.ssid ? ` | SSID: ${iface.ssid}` : '';
                option.textContent = `${iface.name} (${ip})${ssid}`;
                select.appendChild(option);
            });
        }

        function updateStatus(data) {
            const statusText = document.getElementById('statusText');
            const statusIndicator = document.getElementById('statusIndicator');
            
            const running = (data && (data.capture_running === true || data.status === 'running'));
            if (running) {
                statusText.textContent = 'System Running';
                statusIndicator.className = 'status-indicator status-running';
                isCapturing = true;
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
            } else {
                statusText.textContent = 'System Stopped';
                statusIndicator.className = 'status-indicator status-stopped';
                isCapturing = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
            }
        }

        function updateStats(data) {
            // Support both flattened socket payloads and REST payloads
            const ps = (data && data.packet_stats) ? data.packet_stats : data || {};
            const ts = (data && data.threat_stats) ? data.threat_stats : data || {};
            packetCount = Number(ps.total_processed ?? ps.packets_processed ?? 0);
            const captured = Number(ps.total_captured ?? ps.packets_captured ?? 0);
            threatCount = Number(ts.total_threats ?? ts.threats_detected ?? 0);
            anomalyCount = Number(ts.total_anomalies ?? ts.anomalies_detected ?? 0);
            
            document.getElementById('packetCount').textContent = packetCount;
            document.getElementById('threatCount').textContent = threatCount;
            document.getElementById('anomalyCount').textContent = anomalyCount;
            const capEl = document.getElementById('packetsCaptured');
            if (capEl) capEl.textContent = captured;
        }

        function handlePrediction(data) {
            const prediction = data.prediction;
            const anomaly = data.anomaly_detection;
            
            // Increment processed immediately to avoid UI flashing 0
            packetCount++;
            
            if (prediction.is_threat) {
                addEvent(`üö® THREAT: ${prediction.class_name} (${(prediction.confidence * 100).toFixed(1)}%)`, 'threat');
                threatCount++;
                // Pop warning toast for threats
                showToast(`Threat detected: ${prediction.class_name} ${(prediction.confidence * 100).toFixed(1)}%`, 'warn');
                try { triggerSiren(); } catch(e) {}
            } else if (anomaly.is_anomaly) {
                addEvent(`‚ö†Ô∏è ANOMALY: Reconstruction error ${anomaly.reconstruction_error.toFixed(6)}`, 'anomaly');
                anomalyCount++;
            } else {
                addEvent(`‚úÖ NORMAL: ${prediction.class_name} (${(prediction.confidence * 100).toFixed(1)}%)`, 'normal');
            }
            
            // Update tiles synchronously without waiting for next poll
            document.getElementById('packetCount').textContent = packetCount;
            document.getElementById('threatCount').textContent = threatCount;
            document.getElementById('anomalyCount').textContent = anomalyCount;
            const elapsed = Math.max(1, (Date.now() - startTime) / 1000);
            document.getElementById('packetRate').textContent = Math.round(packetCount / elapsed);
        }

        function handleThreatAlert(data) {
            addEvent(`üö® ALERT: ${data.message}`, 'threat');
        }

        function addEvent(message, type) {
            const log = document.getElementById('eventsLog');
            const eventDiv = document.createElement('div');
            eventDiv.className = `event-item event-${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            eventDiv.innerHTML = `<strong>[${timestamp}]</strong> ${message}`;
            
            log.insertBefore(eventDiv, log.firstChild);
            
            // Keep only last 50 events
            while (log.children.length > 50) {
                log.removeChild(log.lastChild);
            }
        }

        function startCapture() {
            const interfaceName = document.getElementById('interfaceSelect').value;
            if (!interfaceName) { alert('Please select a network interface'); return; }
            fetch('/api/start_capture', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ interface: interfaceName })
            })
            .then(r => r.json())
            .then(data => {
                if (!data.success) { alert('Error starting capture: ' + (data.message || 'Unknown')); return; }
                addEvent(`Starting capture on ${interfaceName}`, 'normal');
                startTime = Date.now();
                loadData();
            })
            .catch(e => alert('Error: ' + e));
        }

        function stopCapture() {
            fetch('/api/stop_capture', { method: 'POST', headers: { 'Content-Type': 'application/json' } })
                .then(r => r.json())
                .then(_ => { addEvent('Stopping capture', 'normal'); loadData(); })
                .catch(e => alert('Error: ' + e));
        }

        function clearLog() {
            document.getElementById('eventsLog').innerHTML = '';
            addEvent('Log cleared', 'normal');
        }

        // Initialize charts
        function initCharts() {
            // Threat timeline chart
            const threatData = [{
                x: [],
                y: [],
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Threats',
                line: {color: '#f44336'}
            }];
            
            const threatLayout = {
                title: 'Threat Detection Over Time',
                xaxis: {title: 'Time'},
                yaxis: {title: 'Threat Count'},
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)',
                font: {color: 'white'}
            };
            
            Plotly.newPlot('threatChart', threatData, threatLayout, {responsive: true});
            
            // Classification pie chart
            const classificationData = [{
                values: [1],
                labels: ['Normal'],
                type: 'pie',
                marker: {
                    colors: ['#4CAF50']
                }
            }];
            
            const classificationLayout = {
                title: 'Traffic Classification',
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)',
                font: {color: 'white'}
            };
            
            Plotly.newPlot('classificationChart', classificationData, classificationLayout, {responsive: true});
        }

        function loadData() {
            fetch('/api/data')
                .then(r => r.json())
                .then(d => {
                    updateStatus(d.system_status || {});
                    if (d.packet_stats) {
                        document.getElementById('packetCount').textContent = d.packet_stats.total_processed || d.packet_stats.packets_processed || 0;
                        const capEl = document.getElementById('packetsCaptured');
                        if (capEl) capEl.textContent = d.packet_stats.total_captured || d.packet_stats.packets_captured || 0;
                    }
                })
                .catch(() => {});
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            initCharts();
            // Ask via socket (if a handler exists server-side)
            socket.emit('get_interfaces');
            // Fallback: fetch interfaces via REST API to ensure dropdown populates
            fetch('/api/interfaces')
                .then(resp => resp.json())
                .then(list => updateInterfaces(list))
                .catch(() => {});
            loadData();
            setInterval(loadData, 2000);
            // Init throughput meter
            updateThroughput(0);
        });

        // Mode switch handling
        function switchMode(mode) {
            const live = document.getElementById('liveSection');
            const off = document.getElementById('offlineSection');
            if (mode === 'offline') {
                live.style.display = 'none';
                off.style.display = '';
                document.getElementById('btnLive').classList.remove('btn-primary');
                document.getElementById('btnOffline').classList.add('btn-primary');
            } else {
                off.style.display = 'none';
                live.style.display = '';
                document.getElementById('btnOffline').classList.remove('btn-primary');
                document.getElementById('btnLive').classList.add('btn-primary');
            }
        }

        function uploadPcap() {
            const input = document.getElementById('pcapFile');
            const file = input.files && input.files[0];
            if (!file) {
                alert('Please choose a .pcap or .pcapng file');
                return;
            }
            const fd = new FormData();
            fd.append('file', file);
            const resultDiv = document.getElementById('pcapResult');
            resultDiv.textContent = 'Uploading and analyzing...';
            fetch('/api/upload_pcap', { method: 'POST', body: fd })
                .then(r => r.json())
                .then(data => {
                    if (!data.success) { resultDiv.textContent = 'Error: ' + (data.message || 'Unknown'); return; }
                    const r = data.results || {};
                    resultDiv.textContent = `File: ${r.file || ''} | Processed: ${r.processed}/${r.total_packets} | Threats: ${r.threats} | Anomalies: ${r.anomalies}`;
                    // Show a modal with summary details and top predictions
                    const preds = (r.predictions || []).slice(0, 10);
                    const rows = preds.map(p => {
                        const t = p.timestamp || '';
                        const pi = p.packet_info || {};
                        const pr = p.prediction || {};
                        return `<tr><td>${t}</td><td>${pi.src || ''}</td><td>${pi.dst || ''}</td><td>${pr.class_name || ''}</td><td>${(pr.confidence*100||0).toFixed(1)}%</td><td>${pr.is_threat ? 'Threat' : (p.anomaly_detection && p.anomaly_detection.is_anomaly ? 'Anomaly' : 'Normal')}</td></tr>`;
                    }).join('');
                    const html = `
                        <p><strong>File:</strong> ${r.file || ''}</p>
                        <p><strong>Processed:</strong> ${r.processed}/${r.total_packets} | <strong>Threats:</strong> ${r.threats} | <strong>Anomalies:</strong> ${r.anomalies}</p>
                        <div style="max-height:300px;overflow:auto;background:rgba(255,255,255,0.06);border-radius:6px;padding:8px">
                        <table style="width:100%;border-collapse:collapse;font-size:13px">
                            <thead><tr><th style="text-align:left">Time</th><th style="text-align:left">Src</th><th style="text-align:left">Dst</th><th style="text-align:left">Class</th><th style="text-align:left">Conf</th><th style="text-align:left">Tag</th></tr></thead>
                            <tbody>${rows || '<tr><td colspan=6>No sample predictions</td></tr>'}</tbody>
                        </table>
                        </div>`;
                    showModal('Offline Analysis Results', html);
                })
                .catch(e => { resultDiv.textContent = 'Error: ' + e; });
        }

        // Toast & Modal helpers
        let toastTimer;
        function showToast(message, type='info') {
            const t = document.getElementById('toast');
            t.className = `toast ${type}`;
            t.innerHTML = `<div class='title'>${type==='warn' ? 'Alert' : 'Notice'}</div><div class='small'>${message}</div>`;
            t.classList.add('show');
            clearTimeout(toastTimer);
            toastTimer = setTimeout(() => { t.classList.remove('show'); }, 4000);
        }
        function triggerSiren() {
            const banner = document.getElementById('sirenBanner');
            const audio = document.getElementById('sirenAudio');
            banner.style.display = '';
            banner.style.animation = 'pulse .6s infinite';
            try { audio.currentTime = 0; audio.play(); } catch(e) {}
            setTimeout(() => { banner.style.display = 'none'; banner.style.animation = ''; }, 3500);
        }
        function showModal(title, html) {
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalBody').innerHTML = html;
            document.getElementById('modalOverlay').style.display = 'flex';
        }
        function hideModal(ev) {
            document.getElementById('modalOverlay').style.display = 'none';
        }

        // Anomaly gauge logic
        // Placeholder for future KPI logic
    </script>
</body>
</html>
